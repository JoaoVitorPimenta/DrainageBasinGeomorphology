# -*- coding: utf-8 -*-

'''
/***************************************************************************
 DrainageBasinGeomorphology
                                 A QGIS plugin
 This plugin provides tools for geomorphological analysis in drainage basins.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-22
        copyright            : (C) 2025 by João Vitor Pimenta
        email                : jvpjoaopimenta@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
'''

__author__ = 'João Vitor Pimenta'
__date__ = '2025-03-22'
__copyright__ = '(C) 2025 by João Vitor Pimenta'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import QgsProcessingException
from collections import Counter
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from osgeo import gdal, ogr
import numpy as np
import csv
import itertools
import bisect
import os

def verifyLibs():
        try:
            import numpy
        except ImportError:
            raise QgsProcessingException('Numpy library not found, please install it and try again.')
        try:
            import plotly
        except ImportError:
            raise QgsProcessingException('Plotly library not found, please install it and try again.')

def loadDEM(demLayer):
    DEMpath = demLayer.dataProvider().dataSourceUri().split('|')[0]
    ds = gdal.Open(DEMpath)
    band = ds.GetRasterBand(1)
    demArray = band.ReadAsArray()
    noData = band.GetNoDataValue() if band.GetNoDataValue() is not None else -9999
    gt = ds.GetGeoTransform()
    proj = ds.GetProjection()
    rows, cols = demArray.shape
    ds = None
    return demArray, noData, gt, proj, rows, cols

def EAVAboveBelowProcessing(demArray,noData,gt,proj,cols,rows,basin,distanceContour,minimumLevel,maximumLevel,subtractsBelow,feedback):
    basinGeom = basin.geometry()
    wkb = basinGeom.asWkb()
    ogrGeom = ogr.CreateGeometryFromWkb(wkb)

    rasterDrive = gdal.GetDriverByName('MEM')
    vectorDrive = ogr.GetDriverByName('Memory')
    vectorDriveSource    = vectorDrive.CreateDataSource('wrk')
    vectorLayer = vectorDriveSource.CreateLayer('lyr', None, ogr.wkbUnknown)
    featureDef   = vectorLayer.GetLayerDefn()
    ogrFeat  = ogr.Feature(featureDef)
    ogrFeat.SetGeometry(ogrGeom)
    vectorLayer.CreateFeature(ogrFeat)
    ogrFeat = None

    maskDS = rasterDrive.Create('', cols, rows, 1, gdal.GDT_Byte)
    maskDS.SetGeoTransform(gt)
    maskDS.SetProjection(proj)
    gdal.RasterizeLayer(maskDS, [1], vectorLayer, burn_values=[1])

    mask = maskDS.GetRasterBand(1).ReadAsArray()
    validMask = (mask == 1) & (demArray != noData)
    validDataInsideBasin = demArray[validMask].tolist()

    if not validDataInsideBasin:
        feedback.pushWarning('There is no valid raster data in the basin of id '+str(basin.id())+' and some calculations may be compromised')

    counterValues = Counter(validDataInsideBasin)
    counterValuesFillOrdered = sorted(counterValues.items())
    counterValuesCutOrdered = sorted(counterValues.items(),reverse=True)

    elevationsFill = [item[0] for item in counterValuesFillOrdered]
    originalElevationsFill = [item[0] for item in counterValuesFillOrdered]
    countElevations = [item[1] for item in counterValuesFillOrdered]

    elevationsCut = [item[0] for item in counterValuesCutOrdered]
    originalElevationsCut = [item[0] for item in counterValuesCutOrdered]
    countElevationsCut = [item[1] for item in counterValuesCutOrdered]

    pixelWidth  = abs(gt[1])
    pixelHeight = abs(gt[5])

    maxElevation = max(elevationsFill)
    minElevation = min(elevationsFill)

    areasFill = np.array(countElevations) * (pixelWidth * pixelHeight)
    originalCumulativeAreasFill = np.cumsum(areasFill)
    cumulativeAreasFill = np.cumsum(areasFill)

    areasCut = np.array(countElevationsCut) * (pixelWidth * pixelHeight)
    originalCumulativeAreasFill = np.cumsum(areasCut)
    cumulativeAreasCut = np.cumsum(areasCut)

    if maximumLevel != 0:
        elevationsWithMaximumLevelFill = sorted(elevationsFill)
        elevationsWithMaximumLevelCut = sorted(elevationsCut, reverse=True)
        if maximumLevel not in elevationsFill:
            elevationsWithMaximumLevelFill = sorted(elevationsFill + [maximumLevel])
            elevationsWithMaximumLevelCut = sorted(elevationsCut + [maximumLevel], reverse=True)

            if distanceContour == 0:
                cumulativeAreasFill = np.interp(elevationsWithMaximumLevelFill, elevationsFill, cumulativeAreasFill)
                cumulativeAreasCut = np.interp(elevationsWithMaximumLevelCut, elevationsCut[::-1], cumulativeAreasCut[::-1])

            if distanceContour != 0:
                insertIndexFill = bisect.bisect_right(elevationsFill, maximumLevel)
                neg_elevations = [-e for e in elevationsWithMaximumLevelCut]
                insetIndexCut = bisect.bisect_left(neg_elevations, -maximumLevel)

                if maximumLevel > maxElevation:
                    cumulativeAreasFill = np.insert(cumulativeAreasFill, insertIndexFill, cumulativeAreasFill[-1])
                    cumulativeAreasCut = np.insert(cumulativeAreasCut, insetIndexCut, 0)
                if maximumLevel < maxElevation:
                    cumulativeAreasFill = np.insert(cumulativeAreasFill, insertIndexFill, np.nan)
                    cumulativeAreasCut = np.insert(cumulativeAreasCut, insetIndexCut, np.nan)

            indexCrescent = bisect.bisect_right(elevationsWithMaximumLevelFill, maximumLevel)

            negElevations = [-e for e in elevationsWithMaximumLevelCut]
            indexDecrescent = bisect.bisect_left(negElevations, -maximumLevel)

            elevationsFill = elevationsWithMaximumLevelFill[:indexCrescent]
            cumulativeAreasFill = cumulativeAreasFill[:indexCrescent]

            elevationsCut = elevationsWithMaximumLevelCut[indexDecrescent:]
            cumulativeAreasCut = cumulativeAreasCut[indexDecrescent:]

    if minimumLevel != 0:
        elevationsWithMaximumMinimumLevelCut = sorted(elevationsCut,reverse=True)
        elevationsWithMaximumMinimumLevelFill = sorted(elevationsFill)
        if minimumLevel not in elevationsCut:
            elevationsWithMaximumMinimumLevelCut = sorted(elevationsCut + [minimumLevel],reverse=True)
            elevationsWithMaximumMinimumLevelFill = sorted(elevationsFill + [minimumLevel])

            if distanceContour == 0:
                cumulativeAreasCut = np.interp(elevationsWithMaximumMinimumLevelCut, elevationsCut[::-1], cumulativeAreasCut[::-1])
                cumulativeAreasFill = np.interp(elevationsWithMaximumMinimumLevelFill, elevationsFill, cumulativeAreasFill)

            if distanceContour != 0:
                insertIndexFill = bisect.bisect_left(elevationsFill, minimumLevel)
                neg_elevations = [-e for e in elevationsWithMaximumLevelCut]
                insetIndexCut = bisect.bisect_left(neg_elevations, -minimumLevel)
                if minimumLevel < minElevation:
                    cumulativeAreasCut = np.insert(cumulativeAreasCut, insetIndexCut, cumulativeAreasCut[-1])
                    cumulativeAreasFill = np.insert(cumulativeAreasFill, insertIndexFill, 0)
                if minimumLevel > minElevation:
                    cumulativeAreasCut = np.insert(cumulativeAreasCut, insetIndexCut, np.nan)
                    cumulativeAreasFill = np.insert(cumulativeAreasFill, insertIndexFill, np.nan)

        indexCrescent = bisect.bisect_left(elevationsWithMaximumMinimumLevelFill, minimumLevel)

        negElevations = [-e for e in elevationsWithMaximumMinimumLevelCut]
        indexDecrescent = bisect.bisect_right(negElevations, -minimumLevel)

        elevationsCut = elevationsWithMaximumMinimumLevelCut[:indexDecrescent]
        cumulativeAreasCut = cumulativeAreasCut[:indexDecrescent]

        elevationsFill = elevationsWithMaximumMinimumLevelFill[indexCrescent:]
        cumulativeAreasFill = cumulativeAreasFill[indexCrescent:]

    if distanceContour != 0:
        minElevation = min(elevationsFill)
        maxElevation = max(elevationsFill)

        elevationCurvesFill = np.arange(minElevation, maxElevation, distanceContour)
        if maxElevation not in elevationCurvesFill:
            elevationCurvesFill = np.append(elevationCurvesFill,maxElevation)
        interpAreasFill = np.interp(elevationCurvesFill, originalElevationsFill, originalCumulativeAreasFill, left=0)

        elevationsFill = elevationCurvesFill.tolist()
        cumulativeAreasFill = interpAreasFill

        minElevation = min(elevationsCut)
        maxElevation = max(elevationsCut)

        elevationCurvesCut = np.arange(minElevation, maxElevation, distanceContour)
        if maxElevation not in elevationCurvesCut:
            elevationCurvesCut = np.append(elevationCurvesCut,maxElevation)
        interpAreasCut = np.interp(elevationCurvesCut, originalElevationsCut[::-1], originalCumulativeAreasFill[::-1], right=0)

        elevationsCut = elevationCurvesCut[::-1].tolist()
        cumulativeAreasCut = interpAreasCut[::-1]

    deltaElevFill = np.diff(elevationsFill)
    volumesFill = ((cumulativeAreasFill[1:] + cumulativeAreasFill[:-1])/2) * deltaElevFill
    cumulativeVolumesFill = np.concatenate(([0], np.cumsum(volumesFill)))

    deltaElevCut = abs(np.diff(elevationsCut))
    volumesCut = ((cumulativeAreasCut[1:] + cumulativeAreasCut[:-1])/2) * deltaElevCut
    cumulativeVolumesCut = np.concatenate(([0], np.cumsum(volumesCut)))

    cumulativeAreas = cumulativeAreasCut[::-1] - cumulativeAreasFill
    cumulativeVolumes = cumulativeVolumesCut[::-1] - cumulativeVolumesFill

    elevationWithVolumeZero = np.interp(0, cumulativeVolumes[::-1], elevationsFill[::-1])

    if subtractsBelow is True:
        cumulativeAreas = cumulativeAreasFill - cumulativeAreasCut[::-1]
        cumulativeVolumes = cumulativeVolumesFill - cumulativeVolumesCut[::-1]

        elevationWithVolumeZero = np.interp(0, cumulativeVolumes, elevationsFill)

    feedback.pushInfo('The elevation for the cut/fill volume to be 0 in basin '+str(basin.id())+' is: '+str(elevationWithVolumeZero))

    cumulativeAreasList = cumulativeAreas.tolist()
    cumulativeVolumesList = cumulativeVolumes.tolist()
    return elevationsFill, cumulativeAreasList, cumulativeVolumesList

def runEAVAboveBelow(drainageBasinLayer,demLayer,pathCsv,pathHtml,distanceContour,minimumLevel,maximumLevel,subtractsBelow,feedback):
    feedback.setProgress(0)
    total = drainageBasinLayer.featureCount()
    step = 100.0 / total if total else 0

    os.makedirs(pathHtml, exist_ok=True)

    demArray,noData,gt,proj,rows,cols = loadDEM(demLayer)

    listsWithData = []

    for idx, basin in enumerate(drainageBasinLayer.getFeatures()):
        if feedback.isCanceled():
            return
        feedback.setProgressText('Basin '+str(basin.id())+' processing starting...')
        elevations, cumulativeAreas, cumulativeVolumes = EAVAboveBelowProcessing(demArray,noData,gt,proj,cols,rows,basin,distanceContour,minimumLevel,maximumLevel,subtractsBelow,feedback)

        elevations.insert(0,'Elevation basin '+str(basin.id()))
        cumulativeAreas.insert(0,'Area basin '+str(basin.id()))
        cumulativeVolumes.insert(0,'Volume basin '+str(basin.id()))

        listsWithData.append(elevations)
        listsWithData.append(cumulativeAreas)
        listsWithData.append(cumulativeVolumes)

        feedback.setProgressText('Basin '+str(basin.id())+' processing completed')

        if feedback.isCanceled():
            return

        feedback.setProgressText('Basin '+str(basin.id())+' graph starting...')
        fig = go.Figure()
        fig = make_subplots(specs=[[{"secondary_y": True}]])

        fig.add_trace(go.Scatter(
                                x=cumulativeVolumes,
                                y=elevations,
                                mode='lines',
                                name='Volume - Elevation basin '+str(basin.id())
                                ),
                                secondary_y=False
                                )
        fig.add_trace(go.Scatter(x=cumulativeAreas,
                                y=elevations,
                                mode='lines',
                                name='Area - Elevation basin '+str(basin.id())
                                ),
                                secondary_y=True
                                )

        fig.data[1].update(xaxis='x2')

        fig.update_layout(
            title='Elevation - Area - Volume graph',
            xaxis=dict(title='Volume (m3)'),
            yaxis=dict(title='Elevation (m)'),
            xaxis2=dict(title='Area (m2)',
                        overlaying='x',
                        side='top',
                        autorange='reversed'),
            yaxis2=dict(
                        title='Elevation (m)',
                        overlaying='y',
                        side='right',
                        position=1
                        )
                            )

        outputHTML = os.path.join(pathHtml, 'GRAPH_BASIN_'+str(basin.id())+'.html')
        fig.write_html(outputHTML)

        barProgress = int((idx + 1) * step)
        feedback.setProgress(barProgress)
        feedback.setProgressText('Basin '+str(basin.id())+' graph completed')

        fig.show()

    if feedback.isCanceled():
        return
    feedback.setProgressText('Basin '+str(basin.id())+' graph completed')
    with open(pathCsv, 'w', newline='') as archive:
        writer = csv.writer(archive)
        writer.writerows(itertools.zip_longest(*listsWithData))
