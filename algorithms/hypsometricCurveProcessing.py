# -*- coding: utf-8 -*-

'''
/***************************************************************************
 DrainageBasinGeomorphology
                                 A QGIS plugin
 This plugin provides tools for geomorphological analysis in drainage basins.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-22
        copyright            : (C) 2025 by João Vitor Pimenta
        email                : jvpjoaopimenta@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
'''

__author__ = 'João Vitor Pimenta'
__date__ = '2025-03-22'
__copyright__ = '(C) 2025 by João Vitor Pimenta'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import QgsPointXY, QgsProcessingException
from collections import Counter
import plotly.graph_objects as go
import numpy as np
import csv
import itertools
import os

def verifyLibs():
        try:
            import numpy
        except ImportError:
            raise QgsProcessingException('Numpy library not found, please install it and try again.')

def calculateHypsometricCurve(demLayer,basin,absoluteValues,feedback):
    pixelWidth = demLayer.rasterUnitsPerPixelX()
    pixelHeight = demLayer.rasterUnitsPerPixelY()

    array = demLayer.as_numpy(use_masking=True,bands=[0])
    basinGeom = basin.geometry()
    extent = demLayer.extent()

    validDataInsideBasin = []

    for row in range(demLayer.height()):
        for col in range(demLayer.width()):
            x = extent.xMinimum() + col * pixelWidth + pixelWidth/2
            y = extent.yMaximum() - row * pixelHeight - pixelHeight/2
            point = QgsPointXY(x,y)


            if basinGeom.contains(point):
                value = array[0,row,col]
                validDataInsideBasin.append(value)

    if not validDataInsideBasin:
        feedback.pushWarning('There is no valid raster data in the basin of id '+str(basin.id())+' and some calculations may be compromised')

    counterValues = Counter(validDataInsideBasin)
    counterValuesOrdered = sorted(counterValues.items(),reverse=True)

    elevations = [item[0] for item in counterValuesOrdered]
    countElevations = [item[1] for item in counterValuesOrdered]

    areas = np.array(countElevations) * (pixelWidth * pixelHeight)
    cumulativeAreas = np.cumsum(areas)

    minElevation = min(elevations)
    maxElevation = max(elevations)

    if absoluteValues is True:

        areasList = cumulativeAreas.tolist()

        elevations.insert(0,'Absolute elevation basin '+str(basin.id()))
        areasList.insert(0,'Absolute area basin '+str(basin.id()))

        return elevations, areasList

    normalizedHeights = (np.array(elevations) - minElevation)/(maxElevation - minElevation)
    normalizedHeightsList = normalizedHeights.tolist()

    minArea = min(cumulativeAreas)
    maxArea = max(cumulativeAreas)

    normalizedAreas = (np.array(cumulativeAreas) - minArea)/(maxArea - minArea)
    normalizedAreasList = normalizedAreas.tolist()

    normalizedHeightsList.insert(0,'Normalized elevation (h/H) basin '+str(basin.id()))
    normalizedAreasList.insert(0,'Normalized area (a/A) basin '+str(basin.id()))

    return normalizedHeightsList, normalizedAreasList

def calculateHI(elevations,areas,basin):
    elevationsWOTitle = elevations[1:]
    areasWOTitle = areas[1:]

    hypsometricIntegral = np.trapz(elevationsWOTitle,areasWOTitle)
    listHI = [hypsometricIntegral]
    listHI.insert(0, 'Hypsometric integral basin '+str(basin.id()))

    return listHI

def exportHypsometricCurve(listsWithData,path):
    with open(path, 'w', newline='') as arquivo:
        writer = csv.writer(arquivo)
        writer.writerows(itertools.zip_longest(*listsWithData))

def executeHypsometricCurveProcessing(drainageBasinLayer,demLayer,path,absoluteValues,feedback):
    verifyLibs()

    listsWithData = []
    for basin in drainageBasinLayer.getFeatures():
        heights, cumulativeAreas = calculateHypsometricCurve(demLayer,basin,absoluteValues,feedback)
        hypsometricIntegral =calculateHI(heights,cumulativeAreas,basin)

        listsWithData.append(heights)
        listsWithData.append(cumulativeAreas)
        listsWithData.append(hypsometricIntegral)
    exportHypsometricCurve(listsWithData,path)

def plotGraphHypsometricCurve(drainageBasinLayer,demLayer,path,absoluteValues,feedback):
    verifyLibs()

    fig = go.Figure()

    for basin in drainageBasinLayer.getFeatures():
        heights, cumulativeAreas = calculateHypsometricCurve(demLayer,basin,absoluteValues,feedback)

        hypsometricIntegral =calculateHI(heights,cumulativeAreas,basin)

        fig.add_trace(go.Scatter(x=cumulativeAreas, y=heights, mode='lines',
                                 name='basin '+ str(basin.id())+' Integral = '+str(round(hypsometricIntegral[1],2))))

        if absoluteValues is True:
            fig.update_layout(
            title='Hypsometric graph',
            xaxis_title='Absolute area',
            yaxis_title='Absolute elevation'
        )

        fig.update_layout(
            title='Hypsometric graph',
            xaxis_title='Normalized area (a/A)',
            yaxis_title='Normalized elevation (h/H)'
        )

    fig.show()

    fig.write_html(path)
