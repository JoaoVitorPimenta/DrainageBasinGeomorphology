# -*- coding: utf-8 -*-

'''
/***************************************************************************
 DrainageBasinGeomorphology
                                 A QGIS plugin
 This plugin provides tools for geomorphological analysis in drainage basins.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-22
        copyright            : (C) 2025 by João Vitor Pimenta
        email                : jvpjoaopimenta@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
'''

__author__ = 'João Vitor Pimenta'
__date__ = '2025-03-22'
__copyright__ = '(C) 2025 by João Vitor Pimenta'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import QgsPointXY, QgsProcessingException
from collections import Counter
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
import csv
import itertools
import os

def verifyLibs():
        try:
            import numpy
        except ImportError:
            raise QgsProcessingException('Numpy library not found, please install it and try again.')

        try:
            import plotly
        except ImportError:
            raise QgsProcessingException('Plotly library not found, please install it and try again.')
def EAVprocessing(demLayer,basin,distanceContour,feedback):
    basinGeom = basin.geometry()

    extent = demLayer.extent()

    pixelWidth = demLayer.rasterUnitsPerPixelX()
    pixelHeight = demLayer.rasterUnitsPerPixelY()

    array = demLayer.as_numpy(use_masking=True,bands=[0])
    validDataInsideBasin = []

    for row in range(demLayer.height()):
        for col in range(demLayer.width()):
            x = extent.xMinimum() + col * pixelWidth + pixelWidth/2
            y = extent.yMaximum() - row * pixelHeight - pixelHeight/2
            point = QgsPointXY(x,y)
            
            
            if basinGeom.contains(point):
                value = array[0,row,col]
                validDataInsideBasin.append(value)

    if not validDataInsideBasin:
        feedback.pushWarning('There is no valid raster data in the basin of id '+str(basin.id())+' and some calculations may be compromised')

    counterValues = Counter(validDataInsideBasin)
    counterValuesOrdered = sorted(counterValues.items())

    elevations = [item[0] for item in counterValuesOrdered]
    countElevations = [item[1] for item in counterValuesOrdered]

    areas = np.array(countElevations) * (pixelWidth * pixelHeight)
    cumulativeAreas = np.cumsum(areas)

    deltaElev = np.diff(elevations)
    volumes = cumulativeAreas[1:] * deltaElev
    cumulativeVolumes = np.concatenate(([0], np.cumsum(volumes)))

    if distanceContour != 0:
        minElevation = min(elevations)
        maxElevation = max(elevations)

        elevationCurves = np.arange(minElevation, maxElevation, distanceContour)

        if maxElevation not in elevationCurves:
            elevationCurves = np.append(elevationCurves,maxElevation)

        interpAreas = np.interp(elevationCurves, elevations, cumulativeAreas)
        interpVolumes = np.interp(elevationCurves, elevations, cumulativeVolumes)

        elevations = elevationCurves.tolist()
        cumulativeAreas = interpAreas
        cumulativeVolumes = interpVolumes

    cumulativeAreasList = cumulativeAreas.tolist()
    cumulativeVolumesList = cumulativeVolumes.tolist()
    return elevations, cumulativeAreasList, cumulativeVolumesList

def calculateEAV(drainageBasinLayer,demLayer,path,distanceContour,feedback):
    verifyLibs()

    feedback.setProgress(0)
    total = drainageBasinLayer.featureCount() + 1
    step = 100.0 / total if total else 0

    listsWithData = []

    for idx, basin in enumerate(drainageBasinLayer.getFeatures()):
        if feedback.isCanceled():
            return
        elevations, cumulativeAreas, cumulativeVolumes = EAVprocessing(demLayer,basin,distanceContour,feedback)

        elevations.insert(0,'Elevation basin '+str(basin.id()))
        cumulativeAreas.insert(0,'Area basin '+str(basin.id()))
        cumulativeVolumes.insert(0,'Volume basin '+str(basin.id()))

        listsWithData.append(elevations)
        listsWithData.append(cumulativeAreas)
        listsWithData.append(cumulativeVolumes)

        barProgress = int((idx + 1) * step)
        feedback.setProgress(barProgress)
        feedback.setProgressText('Basin '+str(basin.id())+' processing completed')

    if feedback.isCanceled():
            return
    with open(path, 'w', newline='') as arquivo:
        writer = csv.writer(arquivo)
        writer.writerows(itertools.zip_longest(*listsWithData))

    feedback.setProgress(100)

def plotGraphEAVCurves(drainageBasinLayer,demLayer,path,distanceContour,feedback):
    verifyLibs()

    os.makedirs(path, exist_ok=True)

    feedback.setProgress(0)
    total = drainageBasinLayer.featureCount() + 1
    step = 100.0 / total if total else 0

    for idx, basin in enumerate(drainageBasinLayer.getFeatures()):
        if feedback.isCanceled():
            return

        fig = go.Figure()
        fig = make_subplots(specs=[[{"secondary_y": True}]])

        elevations, cumulativeAreas, cumulativeVolumes = EAVprocessing(demLayer,basin,distanceContour,feedback)

        fig.add_trace(go.Scatter(
                                x=cumulativeVolumes,
                                y=elevations,
                                mode='lines',
                                name='Volume - Elevation basin '+str(basin.id())
                                ),
                                secondary_y=False
                                )
        fig.add_trace(go.Scatter(x=cumulativeAreas,
                                y=elevations,
                                mode='lines',
                                name='Area - Elevation basin '+str(basin.id())
                                ),
                                secondary_y=True
                                )

        fig.data[1].update(xaxis='x2')

        fig.update_layout(
            title='Area x Volume x Elevation',
            xaxis=dict(title='Volume (m3)'),
            yaxis=dict(title='Elevation (m)'),
            xaxis2=dict(title='Area (m2)',
                        overlaying='x',
                        side='top',
                        autorange='reversed'),
            yaxis2=dict(
                        title='Elevation (m)',
                        overlaying='y',
                        side='right',
                        position=1
                        )
                            )

        outputHTML = os.path.join(path, 'GRAPH_BASIN_'+str(basin.id())+'.html')
        fig.write_html(outputHTML)

        barProgress = int((idx + 1) * step)
        feedback.setProgress(barProgress)
        feedback.setProgressText('Basin '+str(basin.id())+' processing graph completed')

        fig.show()

    feedback.setProgress(100)
    